periodical
1

updates = self.get_group_var("id_update", {})
if isinstance(updates, dict) and updates:
    # Inicializar estructuras si no existen
    if not hasattr(self, "account_map") or not isinstance(self.account_map, dict):
        self.account_map = {}
    if not hasattr(self, "name_to_account") or not isinstance(self.name_to_account, dict):
        self.name_to_account = {}
    if not hasattr(self, "partyID") or not isinstance(self.partyID, list):
        self.partyID = []
    if not hasattr(self, "authorized_members") or not isinstance(self.authorized_members, dict):
        self.authorized_members = {}
    if not hasattr(self, "account_positions") or not isinstance(self.account_positions, dict):
        self.account_positions = {}
    if not hasattr(self, "member_ids_list") or not isinstance(self.member_ids_list, list):
        self.member_ids_list = []

    attr51_value = getattr(self, "attr51", [])
    attr51_list = list(attr51_value) if isinstance(attr51_value, list) else []
    member_ids_list = list(self.member_ids_list)

    authorized_names = {
        name for name in attr51_list if isinstance(name, str)
    }
    authorized_names.update(
        name
        for name in getattr(self, "authorized_names", set())
        if isinstance(name, str)
    )

    def _to_int(value):
        try:
            return int(value) if value is not None else None
        except (TypeError, ValueError):
            return None

    def _ensure_length(target_list, index):
        if index >= len(target_list):
            target_list.extend([None] * (index + 1 - len(target_list)))

    for account, info in updates.items():
        if not isinstance(info, dict):
            continue

        new_name = info.get("name")
        old_name = info.get("old_name")
        new_id = _to_int(info.get("id"))
        old_id = _to_int(info.get("old_id"))

        slot_index = self.account_positions.get(account)
        if slot_index is None:
            slot_index = len(attr51_list)
            self.account_positions[account] = slot_index

        _ensure_length(attr51_list, slot_index)
        _ensure_length(member_ids_list, slot_index)

        prev_name = self.account_map.get(account)

        if old_name and old_name != new_name:
            authorized_names.discard(old_name)
            self.name_to_account.pop(old_name, None)

        if prev_name and prev_name != new_name:
            authorized_names.discard(prev_name)
            self.name_to_account.pop(prev_name, None)

        member_entry = self.authorized_members.get(account, {})
        member_entry["index"] = slot_index

        if new_name:
            attr51_list[slot_index] = new_name
            self.account_map[account] = new_name
            self.name_to_account[new_name] = account
            authorized_names.add(new_name)
            member_entry["name"] = new_name
        elif prev_name and slot_index < len(attr51_list):
            attr51_list[slot_index] = prev_name

        if (
            old_id is not None
            and slot_index < len(member_ids_list)
            and member_ids_list[slot_index] == old_id
        ):
            member_ids_list[slot_index] = None

        if new_id is not None:
            member_ids_list[slot_index] = new_id
            member_entry["id"] = new_id
        elif old_id is not None and member_entry.get("id") == old_id:
            member_entry.pop("id", None)

        member_entry["account"] = account
        self.authorized_members[account] = member_entry

    # Actualizar listas persistentes conservando posiciones
    self.attr51 = attr51_list
    self.member_ids_list = member_ids_list
    self.attr52 = member_ids_list

    # Reconstruir partyID con IDs únicos válidos
    unique_ids = []
    seen_ids = set()
    for member_id in member_ids_list:
        if isinstance(member_id, int) and member_id not in seen_ids:
            unique_ids.append(member_id)
            seen_ids.add(member_id)
    self.partyID = unique_ids

    # Generar una vista ordenada para revisión rápida
    self.authorized_roster = [
        {
            "position": idx,
            "account": account,
            "name": self.authorized_members.get(account, {}).get("name"),
            "id": self.authorized_members.get(account, {}).get("id"),
        }
        for account, idx in sorted(
            self.account_positions.items(), key=lambda item: item[1]
        )
    ]

    self.authorized_names = {
        name for name in authorized_names if isinstance(name, str)
    }
    self.set_group_var("id_update", {})