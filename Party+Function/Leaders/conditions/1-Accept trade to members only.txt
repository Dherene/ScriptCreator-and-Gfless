recv_packet
1

parts = self.split_packet(packet)

# El paquete debe tener al menos 7 partes, iniciar con 'dlgi2'
# y el segundo segmento debe ser '#req_exc^...'
if len(parts) >= 7 and parts[0] == "dlgi2" and parts[1].split("^")[0] == "#req_exc":
    session_id = parts[1].split("^")[-1]    # ID del remitente
    sender_name = parts[-1]
    self.current_trader = sender_name
    self.members_received_items = getattr(self, "members_received_items", set())
    self.trade_mode = "pay" if sender_name in self.members_received_items else "receive"

    # Obtener identificador estable (ID de cuenta si est√° disponible)
    identifier = getattr(self, "name_to_account", {}).get(sender_name)
    if identifier is None:
        identifier = sender_name

    authorized_members = getattr(self, "authorized_members", {})
    authorized_accounts = set(authorized_members.keys())
    known_names = {
        info.get("name")
        for info in authorized_members.values()
        if info.get("name")
    }
    known_names.update(getattr(self, "authorized_names", set()))
    attr51_value = getattr(self, "attr51", [])
    if isinstance(attr51_value, list):
        known_names.update(name for name in attr51_value if isinstance(name, str))

    is_authorized = identifier in authorized_accounts or sender_name in known_names

    if is_authorized:
        time.sleep(self.randomize_delay(1, 2))
        print(f"[LEADER] trade accepted by {self.name}")
        self.api.send_packet(f"#req_exc^2^{session_id}")   # aceptar
        selfgroup.trade = "1"  # cerrar comercio para otros miembros
        selfgroup.trade_candidate = None
        lock_info = {
            "name": sender_name,
            "identifier": identifier,
            "session_id": session_id,
        }
        selfgroup.trade_locked_since = time.time()
        selfgroup.trade_locked_by = lock_info
        releases = getattr(selfgroup, "trade_timeout_releases", [])
        if isinstance(releases, list):
            pass
        elif isinstance(releases, (set, tuple)):
            releases = list(releases)
        elif releases is None:
            releases = []
        else:
            releases = [releases]
        filtered_releases = []
        for entry in releases:
            if isinstance(entry, dict):
                if (
                    entry.get("identifier") == identifier
                    or entry.get("name") == sender_name
                    or entry.get("session_id") == session_id
                ):
                    continue
            elif isinstance(entry, (str, int)):
                if str(entry) in {str(identifier), sender_name, str(session_id)}:
                    continue
            filtered_releases.append(entry)
        selfgroup.trade_timeout_releases = filtered_releases
    else:
        time.sleep(self.randomize_delay(3, 5))
        print(f"[LEADER] trade rejected by {self.name}: {sender_name} no autorizado")
        self.api.send_packet(f"#req_exc^5^{session_id}")   # rechazar
        selfgroup.trade = "0"
        selfgroup.trade_candidate = None
        selfgroup.trade_locked_since = None
        selfgroup.trade_locked_by = None
        self.current_trader = None
        self.trade_mode = "receive"