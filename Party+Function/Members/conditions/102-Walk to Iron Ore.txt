periodical
0
import random

MAX_SUBGROUP_MEMBERS = 3


def _encode_iron_ore(data):
    try:
        vnum = int(data.get("vnum", 0))
        pos_x = int(data.get("x", 0))
        pos_y = int(data.get("y", 0))
    except (AttributeError, TypeError, ValueError):
        return 0
    return (vnum << 20) + (pos_x << 10) + pos_y


def _ore_position(data):
    if isinstance(data, dict):
        try:
            return (int(data.get("x")), int(data.get("y")))
        except (TypeError, ValueError):
            return None
    return None


if int(self.map_id) == 6 and int(self.attr1) == 64 and getattr(self, "iron_ore", []):
    time.sleep(self.randomize_delay(1, 1.5))
    cond.off = 0
    if not hasattr(self, "current_iron") or not self.current_iron:
        try:
            member_slot = int(getattr(self, "subgroup_member_index", 0))
        except (TypeError, ValueError):
            member_slot = 0
        if member_slot < 1 or member_slot > MAX_SUBGROUP_MEMBERS:
            member_slot = 0

        assigned_keys = set()
        for slot in range(1, MAX_SUBGROUP_MEMBERS + 1):
            assigned_value = getattr(selfsubg, f"iron_slot_{slot}", 0)
            try:
                encoded = int(assigned_value)
            except (TypeError, ValueError):
                continue
            if encoded > 0:
                assigned_keys.add(encoded)

        occupied_positions = getattr(self, "occupied_iron_positions", set())
        if not isinstance(occupied_positions, set):
            try:
                occupied_positions = set(occupied_positions)
            except TypeError:
                occupied_positions = set()

        ore_candidates = []
        for ore_data in self.iron_ore:
            position = _ore_position(ore_data)
            if position is None:
                continue
            if position in occupied_positions:
                continue
            ore_candidates.append(ore_data)

        random.shuffle(ore_candidates)

        chosen_ore = None
        for ore_data in ore_candidates:
            encoded = _encode_iron_ore(ore_data)
            if encoded not in assigned_keys:
                chosen_ore = ore_data
                break

        if chosen_ore is None:
            if not ore_candidates:
                print(f"15-[MEMBER] {self.name} No free Iron Ore nodes found")
            return

        if chosen_ore is not None:
            try:
                self.iron_ore.remove(chosen_ore)
            except ValueError:
                pass
            self.current_iron = dict(chosen_ore)
            if member_slot:
                setattr(selfsubg, f"iron_slot_{member_slot}", _encode_iron_ore(chosen_ore))

    if getattr(self, "current_iron", None):
        time.sleep(self.randomize_delay(1, 3))
        ore_x = int(self.current_iron.get("x"))
        ore_y = int(self.current_iron.get("y"))
        offsets = [(0,0), (-1,0), (1,0), (0,-1), (0,1), (-1,-1), (-1,1), (1,-1), (1,1)]
        random.shuffle(offsets)
        target_x, target_y = ore_x, ore_y
        walked = False
        for dx, dy in offsets:
            cand_x, cand_y = ore_x + dx, ore_y + dy
            if self.can_reach_point(cand_x, cand_y):
                target_x, target_y = cand_x, cand_y
                walked = True
                break
        if walked:
            self.walk_to_point([target_x, target_y])
            self.current_iron["target_x"] = target_x
            self.current_iron["target_y"] = target_y
            self.target_x = target_x
            self.target_y = target_y
            cond.on = 103
            cond.on = 104
            print(f"15-[MEMBER] {self.name} Walk Iron Ore to ({target_x},{target_y})")
            self.attr1 = 65
        else:
            print(f"15-[MEMBER] {self.name} No walkable tile near iron ore at ({ore_x},{ore_y})")